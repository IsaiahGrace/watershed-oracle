// A parser for the NMEA codes generated by the L96 GNSS module
// Relevant documentation:
// https://aprs.gids.nl/nmea/
// https://www.quectel.com/product/gnss-l96

const std = @import("std");
const interface = @import("interface.zig");

pub fn extractPoint(sentence: Sentence) ?interface.Point {
    var lon: ?f64 = null;
    var lat: ?f64 = null;
    switch (sentence) {
        .GGA => |gga| {
            lon = gga.longitude;
            lat = gga.latitude;
        },
        .RMC => |rmc| {
            lon = rmc.longitude;
            lat = rmc.latitude;
        },
        else => return null,
    }
    if (lon) |x| {
        if (lat) |y| {
            return .{
                .requestId = 0,
                .location = .{ .xy = .{ .x = x, .y = y } },
            };
        }
    }
    return null;
}

pub fn parse(input: []const u8) !Sentence {
    try validateChecksum(input);

    var trimmed = std.mem.trim(u8, input, "$\r\n");
    trimmed = trimmed[0 .. trimmed.len - 3];

    if (std.mem.startsWith(u8, trimmed, "PMTK")) {
        return parsePMTK(trimmed);
    }

    if (std.mem.startsWith(u8, trimmed, "PQ")) {
        return parsePQ(trimmed);
    }

    return parseNMEA(trimmed);
}

fn validateChecksum(input: []const u8) !void {
    var splits = std.mem.splitBackwardsScalar(u8, input, '*');
    var checksumSlice = splits.next() orelse return error.invalidNMEA;
    checksumSlice = std.mem.trim(u8, checksumSlice, "\r\n");
    const checksum = try std.fmt.parseInt(u8, checksumSlice, 16);

    const message = splits.next() orelse return error.invalidNMEA;
    if (message.len == 0 or message[0] != '$') return error.invalidNMEA;

    var calculatedChecksum: u8 = 0;
    for (message[1..]) |c| {
        calculatedChecksum ^= c;
    }

    if (calculatedChecksum != checksum) {
        std.log.err("Invalid checksum: {s}", .{input});
        std.log.err("given: {d} != calculated: {d}", .{ checksum, calculatedChecksum });
        return error.invalidNMEA;
    }
}

fn parsePMTK(input: []const u8) !Sentence {
    _ = input;
    return Sentence{ .TXT = .{} };
}

fn parsePQ(input: []const u8) !Sentence {
    _ = input;
    return Sentence{ .TXT = .{} };
}

fn parseNMEA(input: []const u8) !Sentence {
    var splits = std.mem.splitScalar(u8, input, ',');

    const code = splits.next() orelse return error.invalidNMEA;
    if (code.len != 5) return error.invalidNMEA;
    const talkerID = code[0..2];
    _ = talkerID;
    const sentenceFormatter = code[2..5];

    const msg = splits.rest();

    if (std.mem.eql(u8, sentenceFormatter, "DTM")) return parseDTM(msg);
    if (std.mem.eql(u8, sentenceFormatter, "GBS")) return parseGBS(msg);
    if (std.mem.eql(u8, sentenceFormatter, "GGA")) return parseGGA(msg);
    if (std.mem.eql(u8, sentenceFormatter, "GLL")) return parseGLL(msg);
    if (std.mem.eql(u8, sentenceFormatter, "GSA")) return parseGSA(msg);
    if (std.mem.eql(u8, sentenceFormatter, "GSV")) return parseGSV(msg);
    if (std.mem.eql(u8, sentenceFormatter, "RMC")) return parseRMC(msg);
    if (std.mem.eql(u8, sentenceFormatter, "TXT")) return parseTXT(msg);
    if (std.mem.eql(u8, sentenceFormatter, "VTG")) return parseVTG(msg);

    std.log.err("Invalid NMEA sentence formatter: \"{s}\"", .{sentenceFormatter});
    return error.invalidNMEA;
}

fn parseDTM(msg: []const u8) !Sentence {
    _ = msg;
    return Sentence{ .DTM = .{} };
}

fn parseGBS(msg: []const u8) !Sentence {
    _ = msg;
    return Sentence{ .GBS = .{} };
}

fn parseGGA(msg: []const u8) !Sentence {
    var splits = std.mem.splitScalar(u8, msg, ',');
    const time = try parseUTC(splits.next().?);
    const latitude = try parseLatLon(splits.next().?, splits.next().?);
    const longitude = try parseLatLon(splits.next().?, splits.next().?);
    const quality = splits.next().?;
    const numSatUsed = try std.fmt.parseUnsigned(u8, splits.next().?, 10);
    const hdop = std.fmt.parseFloat(f32, splits.next().?) catch null;
    const altitude = std.fmt.parseFloat(f32, splits.next().?) catch null;
    _ = splits.next().?;
    const seperation = std.fmt.parseFloat(f32, splits.next().?) catch null;
    _ = splits.next().?;
    return Sentence{
        .GGA = .{
            .time = time,
            .latitude = latitude,
            .longitude = longitude,
            .quality = quality[0],
            .numSatUsed = numSatUsed,
            .hdop = hdop,
            .altitude = altitude,
            .seperation = seperation,
        },
    };
}

fn parseGLL(msg: []const u8) !Sentence {
    _ = msg;
    return Sentence{ .GLL = .{} };
}

fn parseGSA(msg: []const u8) !Sentence {
    _ = msg;
    return Sentence{ .GSA = .{} };
}

fn parseGSV(msg: []const u8) !Sentence {
    var splits = std.mem.splitScalar(u8, msg, ',');
    _ = splits.next().?;
    _ = splits.next().?;
    const totalNumSat = try std.fmt.parseUnsigned(u16, splits.next().?, 10);
    return Sentence{
        .GSV = .{
            .totalNumSat = totalNumSat,
        },
    };
}

fn parseRMC(msg: []const u8) !Sentence {
    var splits = std.mem.splitScalar(u8, msg, ',');
    const time = try parseUTC(splits.next().?);
    const status = splits.next().?;
    const latitude = try parseLatLon(splits.next().?, splits.next().?);
    const longitude = try parseLatLon(splits.next().?, splits.next().?);
    const speed = try std.fmt.parseFloat(f32, splits.next().?);
    const course = try std.fmt.parseFloat(f32, splits.next().?);
    const date = try parseDate(splits.next().?);
    const mode = splits.next().?;
    const navStatus = splits.next().?;
    return Sentence{
        .RMC = .{
            .time = time,
            .date = date,
            .status = status[0],
            .navStatus = if (navStatus.len > 0) navStatus[0] else null,
            .latitude = latitude,
            .longitude = longitude,
            .speed = speed,
            .course = course,
            .mode = if (mode.len > 0) mode[0] else null,
        },
    };
}

fn parseTXT(msg: []const u8) !Sentence {
    _ = msg;
    return Sentence{ .TXT = .{} };
}

fn parseVTG(msg: []const u8) !Sentence {
    _ = msg;
    return Sentence{ .VTG = .{} };
}

/// Takes a string representation of lat or lon, and a direction,
/// either N/S or E/W. and returns the signed float.
/// Returns null if either slices are empty.
/// `mag` (magnitude) is in the format:
/// latitudes: "dddmm.mmmmmm"
/// longitudes: "ddmm.mmmmmm"
/// "dd" is degrees: 00 - 90
/// "mm" in minutes: 00 - 59
/// mmmmmm is decimal fraction of minutes (variable length, 4 to 6 digits)
fn parseLatLon(mag: []const u8, dir: []const u8) !?f64 {
    if (dir.len == 0) return null;
    if (mag.len == 0) return null;
    if (dir.len > 1) return error.invalidNMEA;
    if (mag.len < 9) return error.invalidNMEA;
    const i = std.mem.indexOfScalar(u8, mag, '.') orelse return error.invalidNMEA;
    const degrees = try std.fmt.parseFloat(f64, mag[0 .. i - 2]);
    const minutes = try std.fmt.parseFloat(f64, mag[i - 2 ..]);
    const angle = degrees + (minutes / 60.0);
    switch (dir[0]) {
        'N', 'E' => return angle,
        'S', 'W' => return angle * -1.0,
        else => return error.invalidNMEA,
    }
}

/// `utc` is in the format "hhmmss.sss"
fn parseUTC(utc: []const u8) !UTC {
    if (utc.len != 10) return error.invalidNMEA;
    return UTC{
        .hours = try std.fmt.parseUnsigned(u8, utc[0..2], 10),
        .minutes = try std.fmt.parseUnsigned(u8, utc[2..4], 10),
        .seconds = try std.fmt.parseUnsigned(u8, utc[4..6], 10),
        .miliseconds = try std.fmt.parseUnsigned(u16, utc[7..], 10),
    };
}

/// `date` is in the format "ddmmyy"
fn parseDate(date: []const u8) !Date {
    if (date.len != 6) return error.invalidNMEA;
    return Date{
        .day = try std.fmt.parseUnsigned(u8, date[0..2], 10),
        .month = try std.fmt.parseUnsigned(u8, date[2..4], 10),
        .year = try std.fmt.parseUnsigned(u8, date[4..6], 10),
    };
}

const UTC = struct {
    hours: u8, // 0 - 23
    minutes: u8, // 0 - 59
    seconds: u8, // 0 - 59
    miliseconds: u16, // 0 - 599
};

const Date = struct {
    day: u8,
    month: u8,
    year: u8,
};

pub const DTM = struct {};
pub const GBS = struct {};

pub const GGA = struct {
    time: UTC,
    latitude: ?f64,
    longitude: ?f64,
    quality: u8,
    numSatUsed: u8,
    hdop: ?f32,
    altitude: ?f32,
    seperation: ?f32,
};

pub const GLL = struct {};
pub const GSA = struct {};

pub const GSV = struct {
    totalNumSat: u16,
};

pub const RMC = struct {
    time: UTC,
    date: Date,
    status: u8,
    navStatus: ?u8,
    latitude: ?f64,
    longitude: ?f64,
    speed: f32,
    course: f32,
    mode: ?u8,
};

pub const TXT = struct {};
pub const VTG = struct {};

pub const Sentence = union(SentenceFormatter) {
    DTM: DTM,
    GBS: GBS,
    GGA: GGA,
    GLL: GLL,
    GSA: GSA,
    GSV: GSV,
    RMC: RMC,
    TXT: TXT,
    VTG: VTG,
};

pub const SentenceFormatter = enum {
    DTM, // Local geodetic datum and datum offsets from a reference datum.
    GBS, // GNSS Satellite Fault Detection.
    GGA, // Global Positioning System Fix Data.
    GLL, // Geographic Position â€“ Latitude/Longitude.
    GSA, // GNSS dilution of precision (DOP) and Active Satellites.
    GSV, // GNSS Satellites in View.
    RMC, // Recommended Minimum Specific GNSS Data.
    TXT, // Text transmission.
    VTG, // Course Over Ground & Ground Speed.
};

pub fn logSentence(sentence: Sentence) void {
    switch (sentence) {
        .GGA => |gga| logGGA(gga),
        .GSV => |gsv| logGSV(gsv),
        .RMC => |rmc| logRMC(rmc),
        else => std.log.info("{s} parsed.", .{@tagName(sentence)}),
    }
}

fn logGGA(gga: GGA) void {
    if (gga.longitude) |lon| {
        if (gga.latitude) |lat| {
            std.log.info("GGA {d}/{d}/{d} @ {d}:{:0>2}:{d}.{d} : ({d} {d})", .{
                gga.date.month,
                gga.date.day,
                gga.date.year,
                gga.time.hours,
                gga.time.hours,
                gga.time.seconds,
                gga.time.miliseconds,
                lon,
                lat,
            });
            return;
        }
    }
    std.log.info("GGA: no position data.");
}

fn logGSV(gsv: GSV) void {
    std.log.info("GSV: Satilites in view: {d}", .{gsv.totalNumSat});
}

fn logRMC(rmc: RMC) void {
    if (rmc.status == 'V') {
        std.log.info("RMC: no position data.");
    } else {
        std.log.info("RMC: {d}/{d}/{d} @ {d}:{:0>2}:{d}.{d} : ({d} {d})", .{
            rmc.date.month,
            rmc.date.day,
            rmc.date.year,
            rmc.time.hours,
            rmc.time.hours,
            rmc.time.seconds,
            rmc.time.miliseconds,
            rmc.longitude.?,
            rmc.latitude.?,
        });
    }
    // std.log.info("RMC message:", .{});
    // std.log.info("time: {d}:{:0>2}:{d}.{d}", .{ rmc.time.hours, rmc.time.hours, rmc.time.seconds, rmc.time.miliseconds });
    // std.log.info("date: {d}/{d}/{d}", .{ rmc.date.month, rmc.date.day, rmc.date.year });
    // switch (rmc.status) {
    //     'A' => std.log.info("data valid", .{}),
    //     'V' => std.log.info("data invalid", .{}),
    //     'D' => std.log.info("differential mode", .{}),
    //     else => unreachable,
    // }
    // if (rmc.navStatus) |navStatus| {
    //     switch (navStatus) {
    //         'S' => std.log.info("Navigational Status: Safe", .{}),
    //         'C' => std.log.info("Navigational Status: Caution", .{}),
    //         'U' => std.log.info("Navigational Status: Unsafe", .{}),
    //         'V' => std.log.info("Navigational Status: Navigational status not valid. Equipment is not providing navigational status indication.", .{}),
    //         else => unreachable,
    //     }
    // }
    // if (rmc.latitude) |lat| std.log.info("latitude: {d}", .{lat});
    // if (rmc.longitude) |lon| std.log.info("longitude: {d}", .{lon});
    // std.log.info("speed: {d}", .{rmc.speed});
    // std.log.info("course: {d}", .{rmc.course});
    // if (rmc.mode) |mode| {
    //     switch (mode) {
    //         'A' => std.log.info("Mode: Autonomous mode. Satellite system used in non-differential mode in position fix", .{}),
    //         'D' => std.log.info("Mode: Differential mode. Satellite system used in differential mode in position fix. Corrections from ground stations or Satellite Based Augmentation System (SBAS)", .{}),
    //         'E' => std.log.info("Mode: Estimated (dead reckoning) mode", .{}),
    //         'F' => std.log.info("Mode: Float RTK. Satellite system used in RTK mode with floating integers", .{}),
    //         'M' => std.log.info("Mode: Manual input mode", .{}),
    //         'N' => std.log.info("Mode: No fix. Satellite system not used in position fix, or fix not valid", .{}),
    //         'R' => std.log.info("Mode: Real Time Kinematic (RTK). Satellite system used in RTK mode with fixed integers", .{}),
    //         else => unreachable,
    //     }
    // }
}
